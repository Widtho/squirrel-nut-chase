<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Squirrel Nut Chase</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
<script>
let squirrel;
let bunny;
let nuts = [];
let score = 0;
let gameOver = false;
let joystick;
let canvasSize;

function setup() {
  // Set canvas size to fit screen, maintaining aspect ratio
  canvasSize = min(windowWidth, windowHeight * 1.5) * 0.9;
  createCanvas(canvasSize, canvasSize * 0.667); // Maintain 3:2 aspect ratio
  squirrel = new Squirrel();
  bunny = new Bunny();
  for (let i = 0; i < 5; i++) {
    nuts.push(new Nut());
  }
  // Initialize joystick
  joystick = new Joystick(canvasSize * 0.15, canvasSize * 0.55, canvasSize * 0.1);
}

function draw() {
  background(200, 220, 200); // Light green background
  if (!gameOver) {
    squirrel.show();
    squirrel.move();
    bunny.show();
    bunny.move(squirrel.x, squirrel.y);
    // Handle nuts
    for (let i = nuts.length - 1; i >= 0; i--) {
      nuts[i].show();
      if (squirrel.hits(nuts[i])) {
        score += 1;
        nuts.splice(i, 1);
        nuts.push(new Nut());
      }
    }
    // Check for bunny catching squirrel
    if (squirrel.hits(bunny)) {
      gameOver = true;
    }
    // Display score
    textSize(canvasSize * 0.05);
    fill(0);
    text(`Score: ${score}`, canvasSize * 0.02, canvasSize * 0.075);
    // Draw joystick
    joystick.show();
  } else {
    // Game over screen
    textSize(canvasSize * 0.08);
    fill(255, 0, 0);
    textAlign(CENTER);
    text('Game Over!', width / 2, height / 2);
    text(`Final Score: ${score}`, width / 2, height / 2 + canvasSize * 0.1);
    textSize(canvasSize * 0.05);
    text('Press R or Tap to Restart', width / 2, height / 2 + canvasSize * 0.2);
  }
}

function windowResized() {
  // Resize canvas when window size changes
  canvasSize = min(windowWidth, windowHeight * 1.5) * 0.9;
  resizeCanvas(canvasSize, canvasSize * 0.667);
  joystick.x = canvasSize * 0.15;
  joystick.y = canvasSize * 0.55;
  joystick.radius = canvasSize * 0.1;
}

function keyPressed() {
  if (key === 'r' || key === 'R') {
    restartGame();
  }
}

function touchStarted() {
  // Handle joystick touch
  joystick.checkTouch(touches);
  // Restart game if game over and screen is tapped
  if (gameOver) {
    restartGame();
  }
  return false; // Prevent default touch behavior
}

function touchMoved() {
  // Update joystick position during drag
  joystick.checkTouch(touches);
  return false;
}

function touchEnded() {
  // Reset joystick when touch ends
  joystick.reset();
  return false;
}

function restartGame() {
  score = 0;
  gameOver = false;
  nuts = [];
  squirrel = new Squirrel();
  bunny = new Bunny();
  for (let i = 0; i < 5; i++) {
    nuts.push(new Nut());
  }
}

class Squirrel {
  constructor() {
    this.x = canvasSize * 0.083; // Scaled to canvas
    this.y = height / 2;
    this.vx = 0;
    this.vy = 0;
    this.speed = canvasSize * 0.0067; // Scaled speed
    this.width = canvasSize * 0.067; // Scaled size
    this.height = canvasSize * 0.067;
  }

  show() {
    fill(139, 69, 19); // Brown for squirrel
    ellipse(this.x, this.y, this.width, this.height);
  }

  move() {
    this.x += this.vx;
    this.y += this.vy;
    // Handle WASD controls
    if (keyIsDown(87)) { // W key (up)
      this.vy = -this.speed;
    } else if (keyIsDown(83)) { // S key (down)
      this.vy = this.speed;
    } else if (!joystick.isActive || (joystick.dx === 0 && joystick.dy === 0)) {
      this.vy = 0;
    }
    if (keyIsDown(65)) { // A key (left)
      this.vx = -this.speed;
    } else if (keyIsDown(68)) { // D key (right)
      this.vx = this.speed;
    } else if (!joystick.isActive || (joystick.dx === 0 && joystick.dy === 0)) {
      this.vx = 0;
    }
    // Handle joystick input
    if (joystick.isActive) {
      this.vx = joystick.dx * this.speed;
      this.vy = joystick.dy * this.speed;
    }
    // Keep squirrel within canvas bounds
    this.x = constrain(this.x, this.width / 2, width - this.width / 2);
    this.y = constrain(this.y, this.height / 2, height - this.height / 2);
  }

  hits(object) {
    let d = dist(this.x, this.y, object.x, object.y);
    return d < this.width / 2 + object.width / 2;
  }
}

class Bunny {
  constructor() {
    this.x = width - canvasSize * 0.083;
    this.y = height / 2;
    this.speed = canvasSize * 0.0033; // Scaled speed
    this.width = canvasSize * 0.067;
    this.height = canvasSize * 0.067;
  }

  show() {
    fill(255, 255, 255); // White for bunny
    ellipse(this.x, this.y, this.width, this.height);
    fill(255, 0, 0); // Red eyes
    ellipse(this.x - this.width * 0.2, this.y - this.height * 0.125, this.width * 0.125, this.height * 0.125);
    ellipse(this.x + this.width * 0.2, this.y - this.height * 0.125, this.width * 0.125, this.height * 0.125);
  }

  move(targetX, targetY) {
    let dx = targetX - this.x;
    let dy = targetY - this.y;
    let distance = sqrt(dx * dx + dy * dy);
    if (distance > 0) {
      this.x += (dx / distance) * this.speed;
      this.y += (dy / distance) * this.speed;
    }
  }
}

class Nut {
  constructor() {
    this.x = random(width, width + canvasSize * 0.167);
    this.y = random(canvasSize * 0.083, height - canvasSize * 0.083);
    this.width = canvasSize * 0.025;
    this.speed = -canvasSize * 0.005;
  }

  show() {
    fill(210, 105, 30); // Nut color
    ellipse(this.x, this.y, this.width, this.width);
    this.x += this.speed;
    if (this.x < -this.width) {
      this.x = random(width, width + canvasSize * 0.167);
      this.y = random(canvasSize * 0.083, height - canvasSize * 0.083);
    }
  }
}

class Joystick {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.innerRadius = radius * 0.4;
    this.dx = 0;
    this.dy = 0;
    this.isActive = false;
    this.touchX = x;
    this.touchY = y;
  }

  show() {
    // Draw outer circle
    fill(100, 100, 100, 150); // Semi-transparent gray
    ellipse(this.x, this.y, this.radius * 2);
    // Draw inner circle
    fill(200, 200, 200, 200);
    ellipse(this.touchX, this.touchY, this.innerRadius * 2);
  }

  checkTouch(touches) {
    this.isActive = false;
    for (let touch of touches) {
      let d = dist(touch.x, touch.y, this.x, this.y);
      if (d < this.radius) {
        this.isActive = true;
        // Calculate direction vector
        this.dx = (touch.x - this.x) / this.radius;
        this.dy = (touch.y - this.y) / this.radius;
        // Limit to unit vector
        let mag = sqrt(this.dx * this.dx + this.dy * this.dy);
        if (mag > 1) {
          this.dx /= mag;
          this.dy /= mag;
        }
        // Update inner circle position
        this.touchX = this.x + this.dx * this.radius;
        this.touchY = this.y + this.dy * this.radius;
        return;
      }
    }
    this.reset();
  }

  reset() {
    this.dx = 0;
    this.dy = 0;
    this.isActive = false;
    this.touchX = this.x;
    this.touchY = this.y;
  }
}
</script>
</body>
</html>

